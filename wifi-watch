#!/usr/bin/env ruby

require 'pty'

class Pings

  Host = 'ns.google.com'    # A safe bet for a while.
  Period = 300              # Five minute accounting periods.

  @showed_header = false    # Have we showed the destination ip and header yet?
  @dns_failing   = false    # Are DNS lookups failing?

  def run
    last_err = nil
    while true
      ping_period()         # Run one accounting period.
      Process.waitall()     # Soak up any zombie pings.
    end
  rescue Interrupt
    puts                    # Provide a fresh line for the command prompt.
  end

  # Run ping for one accounting period.
  def ping_period()

    current_mode    = nil   # Are we currently good or failing?
    mode_count      = 0     # For how long in a row?
    total_count     = 0     # Pings so far.
    totally_good    = 0     # Successful pings.
    ping_ms         = 0.0   # Latest successful ping time in milliseconds.
    packets_line    = ''    # Ping packets recieved summary line.
    round_trip_line = ''    # Ping round-trip milliseconds summary line.
    filter_line     = nil   # Special wifi login timeout message.

    # Run ping and process each output line.
    PTY.spawn( "ping -c #{Period} #{Host}" ) do |stdin, stdout, pid|
      stdin.each do |line|

        # When DNS is down we cannot even find the host ip to ping.
        if line =~ /cannot resolve/
          # ping: cannot resolve ns.google.com: Unknown host
          STDOUT.write "\r#{ts} #{line.chomp}"
          STDOUT.flush

          # Ping quits quickly so we wait a few seconds before trying again.
          sleep 3
          @dns_failing = true
          return
        else
          # If we were previously failing, pop to a fresh line.
          if @dns_failing
            puts
            @dns_failing = false
          end
        end

        # This records a ping success or failure line. Nil means neither.
        new_mode = nil

        if line =~ /PING/
          #
          # The first ping output line shows the destination ip.
          #
          # PING ns.google.com (216.239.32.10): 56 data bytes
          #
          unless @showed_header
            puts line # Show the destination name and ip.
            puts
            puts "Time  Tot Run Good Failed Round Trip"
            puts "----- --- --- ---- ------ ----------"
            @showed_header = true # Only show these once per wifi-watch.
          end

        elsif line =~ /bytes from/

          if line =~ /time=(\S+)/
            #
            # Success! Record the round trip time.
            #
            # 64 bytes from 104.27.146.148: icmp_seq=48 ttl=61 time=24.780 ms
            # 
            ping_ms = $1.to_f
            new_mode  = 'good'

          else
            #
            # Here the wifi login has timed out and is blocking packets.
            # Multi line ping output shows both the timeout and filter message
            # lines plus some additional diagnostic lines that we ignore.
            #
						# Request timeout for icmp_seq 5
						# 92 bytes from 10.128.128.128: Communication prohibited by filter
						# Vr HL TOS Len ID Flg off TTL Pro cks Src Dst
						# 4 5 00 5400 6dea 0 0000 40 01 21dd 10.57.228.249 104.27.147.148
            #
            unless filter_line
              puts if total_count > 0 # In progress so pop a fresh line.
              puts filter_line = line  # Show the message once.
            end
          end

        elsif line =~ /timeout/
          # Request timeout for icmp_seq 3
          new_mode  = 'fail'

        elsif line =~ /transmitted/
          # 5 packets transmitted, 5 packets received, 0.0% packet loss
          packets_line = line

        elsif line =~ /round-trip/
          # round-trip min/avg/max/stddev = 0.063/0.082/0.122/0.022 ms
          round_trip_line = line
        end

        if new_mode
          # Ping pulse report.
          if new_mode != current_mode
            current_mode  = new_mode
            mode_count    = 0
          end
          mode_count    += 1
          totally_good  += 1 if current_mode == 'good'
          total_count   += 1
          put_line(total_count, totally_good, current_mode, mode_count, ping_ms)
        end

      end
    end

    # Summary line.
    if packets_line =~ /(\d+) packets transmitted, (\d+) packets received/
        total_count   = $1.to_i
        totally_good  = $2.to_i
        if round_trip_line =~ / (\S+) ms/
          avg_ms = $1.split('/')[1].to_f  # Extract the average time.
        end
        put_line(total_count, totally_good, 'good', totally_good, avg_ms)
    end
    puts  # Leave this summary line as history.
  end

  # Rewrite current line.
  def put_line(total_count, totally_good, current_mode, mode_count, ms)
    loss = ((total_count - totally_good) * 100.0) / total_count
    line = sprintf("\r%s %3d %3d %s %5.1f%% %7.2f ms",
                  ts, total_count, mode_count, current_mode, loss, ms)
    STDOUT.write line
    STDOUT.flush
  end

  def ts
    Time.now.strftime('%H:%M')
  end

end

Pings.new.run

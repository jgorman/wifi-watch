#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'pty'

class WifiWatch

  Default_host    = "ns.google.com" # Ping target host.
  Default_count   = 300             # Accounting period in seconds.
  Program         = "wifi-watch"
  Version         = "0.9.0"

  def run
    @shown_header = false # Have we shown the column headers yet?
    @dns_failing  = false # Are DNS lookups failing?
    @options      = get_options()

    while true
      ping_period()         # Run one accounting period.
      Process.waitall()     # Soak up any zombie pings.
    end
  rescue Interrupt
    puts                    # Provide a fresh line for the command prompt.
  end

  def get_options
    options       = OpenStruct.new
    options.host  = Default_host
    options.count = Default_count

    opt_parser = OptionParser.new do |opt|
      opt.banner = "Usage: #{Program} [OPTIONS]"
      opt.separator ""
      opt.on("-h", "--host HOST", "Host to ping [#{options.host}].") do |host|
        options.host = host
      end
      opt.on("-c", "--count SECONDS", Integer,
             "Accounting period in seconds [#{options.count}].") do |count|
        options.count = count
      end
      opt.on("-v", "--version", "Version.") do
        puts Version
        exit
      end
      opt.on("--help", "This message.") do
        puts opt_parser
        exit
      end
    end

    begin
      opt_parser.parse!
    rescue => e
      puts
      puts e
      puts
      puts opt_parser
      puts
      exit
    end

    return options
  end

  # Run ping for one accounting period.
  def ping_period()

    current_mode    = nil   # Are we currently good or failing?
    mode_count      = 0     # For how long in a row?
    total_count     = 0     # Pings so far.
    totally_good    = 0     # Successful pings.
    ping_ms         = 0.0   # Latest successful ping time in milliseconds.
    packets_line    = ''    # Ping packets received summary line.
    round_trip_line = ''    # Ping round-trip milliseconds summary line.
    filter_line     = nil   # Special wifi login timeout message.

    # Run ping and process each output line.
    cmd = "ping -c #{@options.count} #{@options.host}"
    PTY.spawn( cmd ) do |stdin, stdout, pid|
      stdin.each do |line|

        # When DNS is down we cannot even find the host ip to ping.
        if line =~ /cannot resolve/
          # ping: cannot resolve ns.google.com: Unknown host
          STDOUT.write "\r#{ts} #{line.chomp}"
          STDOUT.flush

          # Ping quits quickly so we wait a few seconds before trying again.
          sleep 3
          @dns_failing = true
          return
        else
          # If we were previously failing, pop to a fresh line.
          if @dns_failing
            puts
            @dns_failing = false
          end
        end

        # This records a ping success or failure line. Nil means neither.
        new_mode = nil

        if line =~ /PING/
          #
          # The first ping output line shows the destination ip.
          #
          # PING ns.google.com (216.239.32.10): 56 data bytes
          #
          unless @shown_header
            puts line # Show the destination name and ip.
            puts
            puts "Time  Tot Run Good Failed Round Trip"
            puts "----- --- --- ---- ------ ----------"
            @shown_header = true # Only show these once per wifi-watch.
          end

        elsif line =~ /bytes from/

          if line =~ /time=(\S+)/
            #
            # Success! Record the round trip time.
            #
            # 64 bytes from 104.27.146.148: icmp_seq=48 ttl=61 time=24.780 ms
            # 
            ping_ms = $1.to_f
            new_mode  = 'good'

          else
            #
            # Here the wifi login has timed out and is blocking packets.
            # Multi line ping output shows both the timeout and filter message
            # lines plus some additional diagnostic lines that we ignore.
            #
						# Request timeout for icmp_seq 5
						# 92 bytes from 10.128.128.128: Communication prohibited by filter
						# Vr HL TOS Len ID Flg off TTL Pro cks Src Dst
						# 4 5 00 5400 6dea 0 0000 40 01 21dd 10.57.228.249 104.27.147.148
            #
            unless filter_line
              puts if total_count > 0 # In progress so pop a fresh line.
              puts filter_line = line  # Show the message once.
            end
          end

        elsif line =~ /timeout/
          # Request timeout for icmp_seq 3
          new_mode  = 'fail'

        elsif line =~ /transmitted/
          # 5 packets transmitted, 5 packets received, 0.0% packet loss
          packets_line = line

        elsif line =~ /round-trip/
          # round-trip min/avg/max/stddev = 0.063/0.082/0.122/0.022 ms
          round_trip_line = line
        end

        if new_mode
          # Update the counts with success or failure.
          if new_mode != current_mode
            current_mode  = new_mode
            mode_count    = 0
          end
          mode_count    += 1
          totally_good  += 1 if current_mode == 'good'
          total_count   += 1
          put_line(total_count, totally_good, current_mode, mode_count, ping_ms)
        end

      end
    end

    # Summary line.
    if packets_line =~ /(\d+) packets transmitted, (\d+) packets received/
        total_count   = $1.to_i
        totally_good  = $2.to_i
        if round_trip_line =~ / (\S+) ms/
          avg_ms = $1.split('/')[1].to_f  # Extract the average time.
        end
        put_line(total_count, totally_good, 'good', totally_good, avg_ms)
    end
    puts  # Leave this summary line as history.
  end

  # Rewrite current line.
  def put_line(total_count, totally_good, current_mode, mode_count, ms)
    loss = ((total_count - totally_good) * 100.0) / total_count
    line = sprintf("\r%s %3d %3d %s %5.1f%% %7.2f ms",
                  ts, total_count, mode_count, current_mode, loss, ms)
    STDOUT.write line
    STDOUT.flush
  end

  def ts
    Time.now.strftime('%H:%M')
  end

end

WifiWatch.new.run
